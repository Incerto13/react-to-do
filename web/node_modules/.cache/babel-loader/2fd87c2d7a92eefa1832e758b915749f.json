{"ast":null,"code":"import * as types from \"./actionTypes\";\nimport * as checklistApi from \"../../api/checklistApi\"; // These are ACTION CREATORS for the checklist reducer (department) of the store\n// ensures that each time we fetch checklists, they will be sorted\n\nfunction sortChecklistTasks(checklists) {\n  for (let checklist of checklists) {\n    checklist.tasks.sort((a, b) => {\n      // sort by: completed (false first), then timeOfCompletion\n      return (a.completed === b.completed ? 0 : a.completed ? 1 : -1) || a.timeOfCompletion - b.timeOfCompletion;\n    });\n  }\n\n  return checklists;\n} // returns entire array of checklists\n\n\nexport function fetchChecklists() {\n  return function (dispatch) {\n    return checklistApi.getChecklists() // .then(checklists => sortChecklistTasks(checklists))\n    .then(checklists => {\n      // only call dispatch once you know it was a successfull api call\n      dispatch({\n        type: types.FETCH_CHECKLISTS_SUCCESS,\n        checklists: checklists\n      });\n    }).catch(error => {\n      throw error;\n    });\n  };\n}\n/* this method creates one of two potential actions on a conditional basis\n either update or create depending on if there's already an id\n*/\n\nexport function saveChecklist(checklist) {\n  return function (dispatch, getState) {\n    return checklistApi.saveChecklist(checklist).then(savedChecklist => {\n      checklist.id ? dispatch({\n        type: types.UPDATE_CHECKLIST_SUCCESS,\n        checklist: savedChecklist\n      }) : dispatch({\n        type: types.CREATE_CHECKLIST_SUCCESS,\n        checklist: savedChecklist\n      });\n    }).catch(error => {\n      throw error;\n    });\n  };\n}\nexport function deleteChecklist(checklist) {\n  return function (dispatch) {\n    // Doing optimistic delete, so not dispatching begin/end api call\n    // actions, or apiCallError action since we're not showing the loading status for this.\n    dispatch({\n      type: types.DELETE_CHECKLIST_OPTIMISTIC,\n      checklist\n    });\n    return checklistApi.deleteChecklist(checklist.id);\n  };\n}","map":{"version":3,"sources":["/home/akin/dev/JS/react/Projects/to-do/src/redux/actions/checklistActions.js"],"names":["types","checklistApi","sortChecklistTasks","checklists","checklist","tasks","sort","a","b","completed","timeOfCompletion","fetchChecklists","dispatch","getChecklists","then","type","FETCH_CHECKLISTS_SUCCESS","catch","error","saveChecklist","getState","savedChecklist","id","UPDATE_CHECKLIST_SUCCESS","CREATE_CHECKLIST_SUCCESS","deleteChecklist","DELETE_CHECKLIST_OPTIMISTIC"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,eAAvB;AACA,OAAO,KAAKC,YAAZ,MAA8B,wBAA9B,C,CAEA;AAEA;;AACA,SAASC,kBAAT,CAA4BC,UAA5B,EAAwC;AACtC,OAAK,IAAIC,SAAT,IAAsBD,UAAtB,EAAkC;AAChCC,IAAAA,SAAS,CAACC,KAAV,CAAgBC,IAAhB,CAAqB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC7B;AACA,aACE,CAACD,CAAC,CAACE,SAAF,KAAgBD,CAAC,CAACC,SAAlB,GAA8B,CAA9B,GAAkCF,CAAC,CAACE,SAAF,GAAc,CAAd,GAAkB,CAAC,CAAtD,KACAF,CAAC,CAACG,gBAAF,GAAqBF,CAAC,CAACE,gBAFzB;AAID,KAND;AAOD;;AACD,SAAOP,UAAP;AACD,C,CAED;;;AACA,OAAO,SAASQ,eAAT,GAA2B;AAChC,SAAO,UAASC,QAAT,EAAmB;AACxB,WACEX,YAAY,CACTY,aADH,GAEE;AAFF,KAGGC,IAHH,CAGQX,UAAU,IAAI;AAClB;AACAS,MAAAA,QAAQ,CAAC;AACPG,QAAAA,IAAI,EAAEf,KAAK,CAACgB,wBADL;AAEPb,QAAAA,UAAU,EAAEA;AAFL,OAAD,CAAR;AAID,KATH,EAUGc,KAVH,CAUSC,KAAK,IAAI;AACd,YAAMA,KAAN;AACD,KAZH,CADF;AAeD,GAhBD;AAiBD;AAED;;;;AAGA,OAAO,SAASC,aAAT,CAAuBf,SAAvB,EAAkC;AACvC,SAAO,UAASQ,QAAT,EAAmBQ,QAAnB,EAA6B;AAClC,WAAOnB,YAAY,CAChBkB,aADI,CACUf,SADV,EAEJU,IAFI,CAECO,cAAc,IAAI;AACtBjB,MAAAA,SAAS,CAACkB,EAAV,GACIV,QAAQ,CAAC;AACPG,QAAAA,IAAI,EAAEf,KAAK,CAACuB,wBADL;AAEPnB,QAAAA,SAAS,EAAEiB;AAFJ,OAAD,CADZ,GAKIT,QAAQ,CAAC;AACPG,QAAAA,IAAI,EAAEf,KAAK,CAACwB,wBADL;AAEPpB,QAAAA,SAAS,EAAEiB;AAFJ,OAAD,CALZ;AASD,KAZI,EAaJJ,KAbI,CAaEC,KAAK,IAAI;AACd,YAAMA,KAAN;AACD,KAfI,CAAP;AAgBD,GAjBD;AAkBD;AAED,OAAO,SAASO,eAAT,CAAyBrB,SAAzB,EAAoC;AACzC,SAAO,UAASQ,QAAT,EAAmB;AACxB;AACA;AACAA,IAAAA,QAAQ,CAAC;AAAEG,MAAAA,IAAI,EAAEf,KAAK,CAAC0B,2BAAd;AAA2CtB,MAAAA;AAA3C,KAAD,CAAR;AACA,WAAOH,YAAY,CAACwB,eAAb,CAA6BrB,SAAS,CAACkB,EAAvC,CAAP;AACD,GALD;AAMD","sourcesContent":["import * as types from \"./actionTypes\";\nimport * as checklistApi from \"../../api/checklistApi\";\n\n// These are ACTION CREATORS for the checklist reducer (department) of the store\n\n// ensures that each time we fetch checklists, they will be sorted\nfunction sortChecklistTasks(checklists) {\n  for (let checklist of checklists) {\n    checklist.tasks.sort((a, b) => {\n      // sort by: completed (false first), then timeOfCompletion\n      return (\n        (a.completed === b.completed ? 0 : a.completed ? 1 : -1) ||\n        a.timeOfCompletion - b.timeOfCompletion\n      );\n    });\n  }\n  return checklists;\n}\n\n// returns entire array of checklists\nexport function fetchChecklists() {\n  return function(dispatch) {\n    return (\n      checklistApi\n        .getChecklists()\n        // .then(checklists => sortChecklistTasks(checklists))\n        .then(checklists => {\n          // only call dispatch once you know it was a successfull api call\n          dispatch({\n            type: types.FETCH_CHECKLISTS_SUCCESS,\n            checklists: checklists\n          });\n        })\n        .catch(error => {\n          throw error;\n        })\n    );\n  };\n}\n\n/* this method creates one of two potential actions on a conditional basis\n either update or create depending on if there's already an id\n*/\nexport function saveChecklist(checklist) {\n  return function(dispatch, getState) {\n    return checklistApi\n      .saveChecklist(checklist)\n      .then(savedChecklist => {\n        checklist.id\n          ? dispatch({\n              type: types.UPDATE_CHECKLIST_SUCCESS,\n              checklist: savedChecklist\n            })\n          : dispatch({\n              type: types.CREATE_CHECKLIST_SUCCESS,\n              checklist: savedChecklist\n            });\n      })\n      .catch(error => {\n        throw error;\n      });\n  };\n}\n\nexport function deleteChecklist(checklist) {\n  return function(dispatch) {\n    // Doing optimistic delete, so not dispatching begin/end api call\n    // actions, or apiCallError action since we're not showing the loading status for this.\n    dispatch({ type: types.DELETE_CHECKLIST_OPTIMISTIC, checklist });\n    return checklistApi.deleteChecklist(checklist.id);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}