{"ast":null,"code":"import * as types from \"./actionTypes\";\nimport * as checklistApi from \"../../api/checklistApi\"; // These are ACTION CREATORS for the checklist reducer (department) of the store\n// ensures that each time we fetch checklists, they will be sorted\n// function sortChecklistTasks(checklists) {\n//   for (let checklist of checklists) {\n//     checklist.tasks.sort((a, b) => {\n//       // sort by: completed (false first), then timeOfCompletion\n//       return (\n//         (a.completed === b.completed ? 0 : a.completed ? 1 : -1) ||\n//         a.timeOfCompletion - b.timeOfCompletion\n//       );\n//     });\n//   }\n//   return checklists;\n// }\n// returns entire array of checklists\n\nexport function fetchChecklists() {\n  return function (dispatch) {\n    return checklistApi.getChecklists().then(checklists => {\n      // only call dispatch once you know it was a successfull api call\n      dispatch({\n        type: types.FETCH_CHECKLISTS_SUCCESS,\n        checklists: checklists\n      });\n    }).catch(error => {\n      throw error;\n    });\n  };\n}\n/* this method creates one of two potential actions on a conditional basis\n either update or create depending on if there's already an id\n*/\n\nexport function saveChecklist(checklist) {\n  return function (dispatch, getState) {\n    return checklistApi.saveChecklist(checklist).then(savedChecklist => {\n      checklist.id ? dispatch({\n        type: types.UPDATE_CHECKLIST_SUCCESS,\n        checklist: savedChecklist\n      }) : dispatch({\n        type: types.CREATE_CHECKLIST_SUCCESS,\n        checklist: savedChecklist\n      });\n    }).catch(error => {\n      throw error;\n    });\n  };\n}\nexport function toggleTaskCompletion(checklist, taskId) {\n  const index = checklist.tasks.findIndex(task => {\n    return task.id === taskId;\n  });\n  const oldStatus = checklist.tasks[index].completed;\n  const updatedChecklist = Object.assign({}, checklist);\n  updatedChecklist.tasks[index].completed = !oldStatus;\n  return function (dispatch, getState) {\n    return checklistApi.saveChecklist(updatedChecklist).then(savedChecklist => {\n      updatedChecklist.id ? dispatch({\n        type: types.UPDATE_CHECKLIST_SUCCESS,\n        checklist: savedChecklist\n      }) : dispatch({\n        type: types.CREATE_CHECKLIST_SUCCESS,\n        checklist: savedChecklist\n      });\n    }).catch(error => {\n      throw error;\n    });\n  };\n}\nexport function deleteChecklist(checklist) {\n  return function (dispatch) {\n    // Doing optimistic delete, so not dispatching begin/end api call\n    // actions, or apiCallError action since we're not showing the loading status for this.\n    dispatch({\n      type: types.DELETE_CHECKLIST_OPTIMISTIC,\n      checklist\n    });\n    return checklistApi.deleteChecklist(checklist.id);\n  };\n}","map":{"version":3,"sources":["/home/akin/dev/JS/react/Projects/to-do (backup-fuck-hooks)/src/redux/actions/checklistActions.js"],"names":["types","checklistApi","fetchChecklists","dispatch","getChecklists","then","checklists","type","FETCH_CHECKLISTS_SUCCESS","catch","error","saveChecklist","checklist","getState","savedChecklist","id","UPDATE_CHECKLIST_SUCCESS","CREATE_CHECKLIST_SUCCESS","toggleTaskCompletion","taskId","index","tasks","findIndex","task","oldStatus","completed","updatedChecklist","Object","assign","deleteChecklist","DELETE_CHECKLIST_OPTIMISTIC"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,eAAvB;AACA,OAAO,KAAKC,YAAZ,MAA8B,wBAA9B,C,CAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,OAAO,SAASC,eAAT,GAA2B;AAChC,SAAO,UAASC,QAAT,EAAmB;AACxB,WAAOF,YAAY,CAChBG,aADI,GAEJC,IAFI,CAECC,UAAU,IAAI;AAClB;AACAH,MAAAA,QAAQ,CAAC;AACPI,QAAAA,IAAI,EAAEP,KAAK,CAACQ,wBADL;AAEPF,QAAAA,UAAU,EAAEA;AAFL,OAAD,CAAR;AAID,KARI,EASJG,KATI,CASEC,KAAK,IAAI;AACd,YAAMA,KAAN;AACD,KAXI,CAAP;AAYD,GAbD;AAcD;AAED;;;;AAGA,OAAO,SAASC,aAAT,CAAuBC,SAAvB,EAAkC;AACvC,SAAO,UAAST,QAAT,EAAmBU,QAAnB,EAA6B;AAClC,WAAOZ,YAAY,CAChBU,aADI,CACUC,SADV,EAEJP,IAFI,CAECS,cAAc,IAAI;AACtBF,MAAAA,SAAS,CAACG,EAAV,GACIZ,QAAQ,CAAC;AACPI,QAAAA,IAAI,EAAEP,KAAK,CAACgB,wBADL;AAEPJ,QAAAA,SAAS,EAAEE;AAFJ,OAAD,CADZ,GAKIX,QAAQ,CAAC;AACPI,QAAAA,IAAI,EAAEP,KAAK,CAACiB,wBADL;AAEPL,QAAAA,SAAS,EAAEE;AAFJ,OAAD,CALZ;AASD,KAZI,EAaJL,KAbI,CAaEC,KAAK,IAAI;AACd,YAAMA,KAAN;AACD,KAfI,CAAP;AAgBD,GAjBD;AAkBD;AAED,OAAO,SAASQ,oBAAT,CAA8BN,SAA9B,EAAyCO,MAAzC,EAAiD;AACtD,QAAMC,KAAK,GAAGR,SAAS,CAACS,KAAV,CAAgBC,SAAhB,CAA0BC,IAAI,IAAI;AAC9C,WAAOA,IAAI,CAACR,EAAL,KAAYI,MAAnB;AACD,GAFa,CAAd;AAGA,QAAMK,SAAS,GAAGZ,SAAS,CAACS,KAAV,CAAgBD,KAAhB,EAAuBK,SAAzC;AACA,QAAMC,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBhB,SAAlB,CAAzB;AACAc,EAAAA,gBAAgB,CAACL,KAAjB,CAAuBD,KAAvB,EAA8BK,SAA9B,GAA0C,CAACD,SAA3C;AACA,SAAO,UAASrB,QAAT,EAAmBU,QAAnB,EAA6B;AAClC,WAAOZ,YAAY,CAChBU,aADI,CACUe,gBADV,EAEJrB,IAFI,CAECS,cAAc,IAAI;AACtBY,MAAAA,gBAAgB,CAACX,EAAjB,GACIZ,QAAQ,CAAC;AACPI,QAAAA,IAAI,EAAEP,KAAK,CAACgB,wBADL;AAEPJ,QAAAA,SAAS,EAAEE;AAFJ,OAAD,CADZ,GAKIX,QAAQ,CAAC;AACPI,QAAAA,IAAI,EAAEP,KAAK,CAACiB,wBADL;AAEPL,QAAAA,SAAS,EAAEE;AAFJ,OAAD,CALZ;AASD,KAZI,EAaJL,KAbI,CAaEC,KAAK,IAAI;AACd,YAAMA,KAAN;AACD,KAfI,CAAP;AAgBD,GAjBD;AAkBD;AAED,OAAO,SAASmB,eAAT,CAAyBjB,SAAzB,EAAoC;AACzC,SAAO,UAAST,QAAT,EAAmB;AACxB;AACA;AACAA,IAAAA,QAAQ,CAAC;AAAEI,MAAAA,IAAI,EAAEP,KAAK,CAAC8B,2BAAd;AAA2ClB,MAAAA;AAA3C,KAAD,CAAR;AACA,WAAOX,YAAY,CAAC4B,eAAb,CAA6BjB,SAAS,CAACG,EAAvC,CAAP;AACD,GALD;AAMD","sourcesContent":["import * as types from \"./actionTypes\";\nimport * as checklistApi from \"../../api/checklistApi\";\n\n// These are ACTION CREATORS for the checklist reducer (department) of the store\n\n// ensures that each time we fetch checklists, they will be sorted\n// function sortChecklistTasks(checklists) {\n//   for (let checklist of checklists) {\n//     checklist.tasks.sort((a, b) => {\n//       // sort by: completed (false first), then timeOfCompletion\n//       return (\n//         (a.completed === b.completed ? 0 : a.completed ? 1 : -1) ||\n//         a.timeOfCompletion - b.timeOfCompletion\n//       );\n//     });\n//   }\n//   return checklists;\n// }\n\n// returns entire array of checklists\nexport function fetchChecklists() {\n  return function(dispatch) {\n    return checklistApi\n      .getChecklists()\n      .then(checklists => {\n        // only call dispatch once you know it was a successfull api call\n        dispatch({\n          type: types.FETCH_CHECKLISTS_SUCCESS,\n          checklists: checklists\n        });\n      })\n      .catch(error => {\n        throw error;\n      });\n  };\n}\n\n/* this method creates one of two potential actions on a conditional basis\n either update or create depending on if there's already an id\n*/\nexport function saveChecklist(checklist) {\n  return function(dispatch, getState) {\n    return checklistApi\n      .saveChecklist(checklist)\n      .then(savedChecklist => {\n        checklist.id\n          ? dispatch({\n              type: types.UPDATE_CHECKLIST_SUCCESS,\n              checklist: savedChecklist\n            })\n          : dispatch({\n              type: types.CREATE_CHECKLIST_SUCCESS,\n              checklist: savedChecklist\n            });\n      })\n      .catch(error => {\n        throw error;\n      });\n  };\n}\n\nexport function toggleTaskCompletion(checklist, taskId) {\n  const index = checklist.tasks.findIndex(task => {\n    return task.id === taskId;\n  });\n  const oldStatus = checklist.tasks[index].completed;\n  const updatedChecklist = Object.assign({}, checklist);\n  updatedChecklist.tasks[index].completed = !oldStatus;\n  return function(dispatch, getState) {\n    return checklistApi\n      .saveChecklist(updatedChecklist)\n      .then(savedChecklist => {\n        updatedChecklist.id\n          ? dispatch({\n              type: types.UPDATE_CHECKLIST_SUCCESS,\n              checklist: savedChecklist\n            })\n          : dispatch({\n              type: types.CREATE_CHECKLIST_SUCCESS,\n              checklist: savedChecklist\n            });\n      })\n      .catch(error => {\n        throw error;\n      });\n  };\n}\n\nexport function deleteChecklist(checklist) {\n  return function(dispatch) {\n    // Doing optimistic delete, so not dispatching begin/end api call\n    // actions, or apiCallError action since we're not showing the loading status for this.\n    dispatch({ type: types.DELETE_CHECKLIST_OPTIMISTIC, checklist });\n    return checklistApi.deleteChecklist(checklist.id);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}